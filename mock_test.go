// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package dotsqlx

import (
	"context"
	"database/sql"
	"github.com/jmoiron/sqlx"
	"sync"
)

var (
	lockPreparerxMockPreparex sync.RWMutex
)

// Ensure, that PreparerxMock does implement Preparerx.
// If this is not the case, regenerate this file with moq.
var _ Preparerx = &PreparerxMock{}

// PreparerxMock is a mock implementation of Preparerx.
//
//     func TestSomethingThatUsesPreparerx(t *testing.T) {
//
//         // make and configure a mocked Preparerx
//         mockedPreparerx := &PreparerxMock{
//             PreparexFunc: func(query string) (*sqlx.Stmt, error) {
// 	               panic("mock out the Preparex method")
//             },
//         }
//
//         // use mockedPreparerx in code that requires Preparerx
//         // and then make assertions.
//
//     }
type PreparerxMock struct {
	// PreparexFunc mocks the Preparex method.
	PreparexFunc func(query string) (*sqlx.Stmt, error)

	// calls tracks calls to the methods.
	calls struct {
		// Preparex holds details about calls to the Preparex method.
		Preparex []struct {
			// Query is the query argument value.
			Query string
		}
	}
}

// Preparex calls PreparexFunc.
func (mock *PreparerxMock) Preparex(query string) (*sqlx.Stmt, error) {
	if mock.PreparexFunc == nil {
		panic("PreparerxMock.PreparexFunc: method is nil but Preparerx.Preparex was just called")
	}
	callInfo := struct {
		Query string
	}{
		Query: query,
	}
	lockPreparerxMockPreparex.Lock()
	mock.calls.Preparex = append(mock.calls.Preparex, callInfo)
	lockPreparerxMockPreparex.Unlock()
	return mock.PreparexFunc(query)
}

// PreparexCalls gets all the calls that were made to Preparex.
// Check the length with:
//     len(mockedPreparerx.PreparexCalls())
func (mock *PreparerxMock) PreparexCalls() []struct {
	Query string
} {
	var calls []struct {
		Query string
	}
	lockPreparerxMockPreparex.RLock()
	calls = mock.calls.Preparex
	lockPreparerxMockPreparex.RUnlock()
	return calls
}

var (
	lockPreparerxContextMockPreparexContext sync.RWMutex
)

// Ensure, that PreparerxContextMock does implement PreparerxContext.
// If this is not the case, regenerate this file with moq.
var _ PreparerxContext = &PreparerxContextMock{}

// PreparerxContextMock is a mock implementation of PreparerxContext.
//
//     func TestSomethingThatUsesPreparerxContext(t *testing.T) {
//
//         // make and configure a mocked PreparerxContext
//         mockedPreparerxContext := &PreparerxContextMock{
//             PreparexContextFunc: func(ctx context.Context, query string) (*sqlx.Stmt, error) {
// 	               panic("mock out the PreparexContext method")
//             },
//         }
//
//         // use mockedPreparerxContext in code that requires PreparerxContext
//         // and then make assertions.
//
//     }
type PreparerxContextMock struct {
	// PreparexContextFunc mocks the PreparexContext method.
	PreparexContextFunc func(ctx context.Context, query string) (*sqlx.Stmt, error)

	// calls tracks calls to the methods.
	calls struct {
		// PreparexContext holds details about calls to the PreparexContext method.
		PreparexContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Query is the query argument value.
			Query string
		}
	}
}

// PreparexContext calls PreparexContextFunc.
func (mock *PreparerxContextMock) PreparexContext(ctx context.Context, query string) (*sqlx.Stmt, error) {
	if mock.PreparexContextFunc == nil {
		panic("PreparerxContextMock.PreparexContextFunc: method is nil but PreparerxContext.PreparexContext was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Query string
	}{
		Ctx:   ctx,
		Query: query,
	}
	lockPreparerxContextMockPreparexContext.Lock()
	mock.calls.PreparexContext = append(mock.calls.PreparexContext, callInfo)
	lockPreparerxContextMockPreparexContext.Unlock()
	return mock.PreparexContextFunc(ctx, query)
}

// PreparexContextCalls gets all the calls that were made to PreparexContext.
// Check the length with:
//     len(mockedPreparerxContext.PreparexContextCalls())
func (mock *PreparerxContextMock) PreparexContextCalls() []struct {
	Ctx   context.Context
	Query string
} {
	var calls []struct {
		Ctx   context.Context
		Query string
	}
	lockPreparerxContextMockPreparexContext.RLock()
	calls = mock.calls.PreparexContext
	lockPreparerxContextMockPreparexContext.RUnlock()
	return calls
}

var (
	lockGetterMockGet sync.RWMutex
)

// Ensure, that GetterMock does implement Getter.
// If this is not the case, regenerate this file with moq.
var _ Getter = &GetterMock{}

// GetterMock is a mock implementation of Getter.
//
//     func TestSomethingThatUsesGetter(t *testing.T) {
//
//         // make and configure a mocked Getter
//         mockedGetter := &GetterMock{
//             GetFunc: func(dest interface{}, query string, args ...interface{}) error {
// 	               panic("mock out the Get method")
//             },
//         }
//
//         // use mockedGetter in code that requires Getter
//         // and then make assertions.
//
//     }
type GetterMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(dest interface{}, query string, args ...interface{}) error

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Dest is the dest argument value.
			Dest interface{}
			// Query is the query argument value.
			Query string
			// Args is the args argument value.
			Args []interface{}
		}
	}
}

// Get calls GetFunc.
func (mock *GetterMock) Get(dest interface{}, query string, args ...interface{}) error {
	if mock.GetFunc == nil {
		panic("GetterMock.GetFunc: method is nil but Getter.Get was just called")
	}
	callInfo := struct {
		Dest  interface{}
		Query string
		Args  []interface{}
	}{
		Dest:  dest,
		Query: query,
		Args:  args,
	}
	lockGetterMockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	lockGetterMockGet.Unlock()
	return mock.GetFunc(dest, query, args...)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//     len(mockedGetter.GetCalls())
func (mock *GetterMock) GetCalls() []struct {
	Dest  interface{}
	Query string
	Args  []interface{}
} {
	var calls []struct {
		Dest  interface{}
		Query string
		Args  []interface{}
	}
	lockGetterMockGet.RLock()
	calls = mock.calls.Get
	lockGetterMockGet.RUnlock()
	return calls
}

var (
	lockGetterContextMockGetContext sync.RWMutex
)

// Ensure, that GetterContextMock does implement GetterContext.
// If this is not the case, regenerate this file with moq.
var _ GetterContext = &GetterContextMock{}

// GetterContextMock is a mock implementation of GetterContext.
//
//     func TestSomethingThatUsesGetterContext(t *testing.T) {
//
//         // make and configure a mocked GetterContext
//         mockedGetterContext := &GetterContextMock{
//             GetContextFunc: func(ctx context.Context, dest interface{}, query string, args ...interface{}) error {
// 	               panic("mock out the GetContext method")
//             },
//         }
//
//         // use mockedGetterContext in code that requires GetterContext
//         // and then make assertions.
//
//     }
type GetterContextMock struct {
	// GetContextFunc mocks the GetContext method.
	GetContextFunc func(ctx context.Context, dest interface{}, query string, args ...interface{}) error

	// calls tracks calls to the methods.
	calls struct {
		// GetContext holds details about calls to the GetContext method.
		GetContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Dest is the dest argument value.
			Dest interface{}
			// Query is the query argument value.
			Query string
			// Args is the args argument value.
			Args []interface{}
		}
	}
}

// GetContext calls GetContextFunc.
func (mock *GetterContextMock) GetContext(ctx context.Context, dest interface{}, query string, args ...interface{}) error {
	if mock.GetContextFunc == nil {
		panic("GetterContextMock.GetContextFunc: method is nil but GetterContext.GetContext was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Dest  interface{}
		Query string
		Args  []interface{}
	}{
		Ctx:   ctx,
		Dest:  dest,
		Query: query,
		Args:  args,
	}
	lockGetterContextMockGetContext.Lock()
	mock.calls.GetContext = append(mock.calls.GetContext, callInfo)
	lockGetterContextMockGetContext.Unlock()
	return mock.GetContextFunc(ctx, dest, query, args...)
}

// GetContextCalls gets all the calls that were made to GetContext.
// Check the length with:
//     len(mockedGetterContext.GetContextCalls())
func (mock *GetterContextMock) GetContextCalls() []struct {
	Ctx   context.Context
	Dest  interface{}
	Query string
	Args  []interface{}
} {
	var calls []struct {
		Ctx   context.Context
		Dest  interface{}
		Query string
		Args  []interface{}
	}
	lockGetterContextMockGetContext.RLock()
	calls = mock.calls.GetContext
	lockGetterContextMockGetContext.RUnlock()
	return calls
}

var (
	lockSelecterMockSelect sync.RWMutex
)

// Ensure, that SelecterMock does implement Selecter.
// If this is not the case, regenerate this file with moq.
var _ Selecter = &SelecterMock{}

// SelecterMock is a mock implementation of Selecter.
//
//     func TestSomethingThatUsesSelecter(t *testing.T) {
//
//         // make and configure a mocked Selecter
//         mockedSelecter := &SelecterMock{
//             SelectFunc: func(dest interface{}, query string, args ...interface{}) error {
// 	               panic("mock out the Select method")
//             },
//         }
//
//         // use mockedSelecter in code that requires Selecter
//         // and then make assertions.
//
//     }
type SelecterMock struct {
	// SelectFunc mocks the Select method.
	SelectFunc func(dest interface{}, query string, args ...interface{}) error

	// calls tracks calls to the methods.
	calls struct {
		// Select holds details about calls to the Select method.
		Select []struct {
			// Dest is the dest argument value.
			Dest interface{}
			// Query is the query argument value.
			Query string
			// Args is the args argument value.
			Args []interface{}
		}
	}
}

// Select calls SelectFunc.
func (mock *SelecterMock) Select(dest interface{}, query string, args ...interface{}) error {
	if mock.SelectFunc == nil {
		panic("SelecterMock.SelectFunc: method is nil but Selecter.Select was just called")
	}
	callInfo := struct {
		Dest  interface{}
		Query string
		Args  []interface{}
	}{
		Dest:  dest,
		Query: query,
		Args:  args,
	}
	lockSelecterMockSelect.Lock()
	mock.calls.Select = append(mock.calls.Select, callInfo)
	lockSelecterMockSelect.Unlock()
	return mock.SelectFunc(dest, query, args...)
}

// SelectCalls gets all the calls that were made to Select.
// Check the length with:
//     len(mockedSelecter.SelectCalls())
func (mock *SelecterMock) SelectCalls() []struct {
	Dest  interface{}
	Query string
	Args  []interface{}
} {
	var calls []struct {
		Dest  interface{}
		Query string
		Args  []interface{}
	}
	lockSelecterMockSelect.RLock()
	calls = mock.calls.Select
	lockSelecterMockSelect.RUnlock()
	return calls
}

var (
	lockSelecterContextMockSelectContext sync.RWMutex
)

// Ensure, that SelecterContextMock does implement SelecterContext.
// If this is not the case, regenerate this file with moq.
var _ SelecterContext = &SelecterContextMock{}

// SelecterContextMock is a mock implementation of SelecterContext.
//
//     func TestSomethingThatUsesSelecterContext(t *testing.T) {
//
//         // make and configure a mocked SelecterContext
//         mockedSelecterContext := &SelecterContextMock{
//             SelectContextFunc: func(ctx context.Context, dest interface{}, query string, args ...interface{}) error {
// 	               panic("mock out the SelectContext method")
//             },
//         }
//
//         // use mockedSelecterContext in code that requires SelecterContext
//         // and then make assertions.
//
//     }
type SelecterContextMock struct {
	// SelectContextFunc mocks the SelectContext method.
	SelectContextFunc func(ctx context.Context, dest interface{}, query string, args ...interface{}) error

	// calls tracks calls to the methods.
	calls struct {
		// SelectContext holds details about calls to the SelectContext method.
		SelectContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Dest is the dest argument value.
			Dest interface{}
			// Query is the query argument value.
			Query string
			// Args is the args argument value.
			Args []interface{}
		}
	}
}

// SelectContext calls SelectContextFunc.
func (mock *SelecterContextMock) SelectContext(ctx context.Context, dest interface{}, query string, args ...interface{}) error {
	if mock.SelectContextFunc == nil {
		panic("SelecterContextMock.SelectContextFunc: method is nil but SelecterContext.SelectContext was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Dest  interface{}
		Query string
		Args  []interface{}
	}{
		Ctx:   ctx,
		Dest:  dest,
		Query: query,
		Args:  args,
	}
	lockSelecterContextMockSelectContext.Lock()
	mock.calls.SelectContext = append(mock.calls.SelectContext, callInfo)
	lockSelecterContextMockSelectContext.Unlock()
	return mock.SelectContextFunc(ctx, dest, query, args...)
}

// SelectContextCalls gets all the calls that were made to SelectContext.
// Check the length with:
//     len(mockedSelecterContext.SelectContextCalls())
func (mock *SelecterContextMock) SelectContextCalls() []struct {
	Ctx   context.Context
	Dest  interface{}
	Query string
	Args  []interface{}
} {
	var calls []struct {
		Ctx   context.Context
		Dest  interface{}
		Query string
		Args  []interface{}
	}
	lockSelecterContextMockSelectContext.RLock()
	calls = mock.calls.SelectContext
	lockSelecterContextMockSelectContext.RUnlock()
	return calls
}

var (
	lockQueryerxMockQueryx sync.RWMutex
)

// Ensure, that QueryerxMock does implement Queryerx.
// If this is not the case, regenerate this file with moq.
var _ Queryerx = &QueryerxMock{}

// QueryerxMock is a mock implementation of Queryerx.
//
//     func TestSomethingThatUsesQueryerx(t *testing.T) {
//
//         // make and configure a mocked Queryerx
//         mockedQueryerx := &QueryerxMock{
//             QueryxFunc: func(query string, args ...interface{}) (*sqlx.Rows, error) {
// 	               panic("mock out the Queryx method")
//             },
//         }
//
//         // use mockedQueryerx in code that requires Queryerx
//         // and then make assertions.
//
//     }
type QueryerxMock struct {
	// QueryxFunc mocks the Queryx method.
	QueryxFunc func(query string, args ...interface{}) (*sqlx.Rows, error)

	// calls tracks calls to the methods.
	calls struct {
		// Queryx holds details about calls to the Queryx method.
		Queryx []struct {
			// Query is the query argument value.
			Query string
			// Args is the args argument value.
			Args []interface{}
		}
	}
}

// Queryx calls QueryxFunc.
func (mock *QueryerxMock) Queryx(query string, args ...interface{}) (*sqlx.Rows, error) {
	if mock.QueryxFunc == nil {
		panic("QueryerxMock.QueryxFunc: method is nil but Queryerx.Queryx was just called")
	}
	callInfo := struct {
		Query string
		Args  []interface{}
	}{
		Query: query,
		Args:  args,
	}
	lockQueryerxMockQueryx.Lock()
	mock.calls.Queryx = append(mock.calls.Queryx, callInfo)
	lockQueryerxMockQueryx.Unlock()
	return mock.QueryxFunc(query, args...)
}

// QueryxCalls gets all the calls that were made to Queryx.
// Check the length with:
//     len(mockedQueryerx.QueryxCalls())
func (mock *QueryerxMock) QueryxCalls() []struct {
	Query string
	Args  []interface{}
} {
	var calls []struct {
		Query string
		Args  []interface{}
	}
	lockQueryerxMockQueryx.RLock()
	calls = mock.calls.Queryx
	lockQueryerxMockQueryx.RUnlock()
	return calls
}

var (
	lockQueryerxContextMockQueryxContext sync.RWMutex
)

// Ensure, that QueryerxContextMock does implement QueryerxContext.
// If this is not the case, regenerate this file with moq.
var _ QueryerxContext = &QueryerxContextMock{}

// QueryerxContextMock is a mock implementation of QueryerxContext.
//
//     func TestSomethingThatUsesQueryerxContext(t *testing.T) {
//
//         // make and configure a mocked QueryerxContext
//         mockedQueryerxContext := &QueryerxContextMock{
//             QueryxContextFunc: func(ctx context.Context, query string, args ...interface{}) (*sqlx.Rows, error) {
// 	               panic("mock out the QueryxContext method")
//             },
//         }
//
//         // use mockedQueryerxContext in code that requires QueryerxContext
//         // and then make assertions.
//
//     }
type QueryerxContextMock struct {
	// QueryxContextFunc mocks the QueryxContext method.
	QueryxContextFunc func(ctx context.Context, query string, args ...interface{}) (*sqlx.Rows, error)

	// calls tracks calls to the methods.
	calls struct {
		// QueryxContext holds details about calls to the QueryxContext method.
		QueryxContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Query is the query argument value.
			Query string
			// Args is the args argument value.
			Args []interface{}
		}
	}
}

// QueryxContext calls QueryxContextFunc.
func (mock *QueryerxContextMock) QueryxContext(ctx context.Context, query string, args ...interface{}) (*sqlx.Rows, error) {
	if mock.QueryxContextFunc == nil {
		panic("QueryerxContextMock.QueryxContextFunc: method is nil but QueryerxContext.QueryxContext was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Query string
		Args  []interface{}
	}{
		Ctx:   ctx,
		Query: query,
		Args:  args,
	}
	lockQueryerxContextMockQueryxContext.Lock()
	mock.calls.QueryxContext = append(mock.calls.QueryxContext, callInfo)
	lockQueryerxContextMockQueryxContext.Unlock()
	return mock.QueryxContextFunc(ctx, query, args...)
}

// QueryxContextCalls gets all the calls that were made to QueryxContext.
// Check the length with:
//     len(mockedQueryerxContext.QueryxContextCalls())
func (mock *QueryerxContextMock) QueryxContextCalls() []struct {
	Ctx   context.Context
	Query string
	Args  []interface{}
} {
	var calls []struct {
		Ctx   context.Context
		Query string
		Args  []interface{}
	}
	lockQueryerxContextMockQueryxContext.RLock()
	calls = mock.calls.QueryxContext
	lockQueryerxContextMockQueryxContext.RUnlock()
	return calls
}

var (
	lockQueryRowerxMockQueryRowx sync.RWMutex
)

// Ensure, that QueryRowerxMock does implement QueryRowerx.
// If this is not the case, regenerate this file with moq.
var _ QueryRowerx = &QueryRowerxMock{}

// QueryRowerxMock is a mock implementation of QueryRowerx.
//
//     func TestSomethingThatUsesQueryRowerx(t *testing.T) {
//
//         // make and configure a mocked QueryRowerx
//         mockedQueryRowerx := &QueryRowerxMock{
//             QueryRowxFunc: func(query string, args ...interface{}) *sqlx.Row {
// 	               panic("mock out the QueryRowx method")
//             },
//         }
//
//         // use mockedQueryRowerx in code that requires QueryRowerx
//         // and then make assertions.
//
//     }
type QueryRowerxMock struct {
	// QueryRowxFunc mocks the QueryRowx method.
	QueryRowxFunc func(query string, args ...interface{}) *sqlx.Row

	// calls tracks calls to the methods.
	calls struct {
		// QueryRowx holds details about calls to the QueryRowx method.
		QueryRowx []struct {
			// Query is the query argument value.
			Query string
			// Args is the args argument value.
			Args []interface{}
		}
	}
}

// QueryRowx calls QueryRowxFunc.
func (mock *QueryRowerxMock) QueryRowx(query string, args ...interface{}) *sqlx.Row {
	if mock.QueryRowxFunc == nil {
		panic("QueryRowerxMock.QueryRowxFunc: method is nil but QueryRowerx.QueryRowx was just called")
	}
	callInfo := struct {
		Query string
		Args  []interface{}
	}{
		Query: query,
		Args:  args,
	}
	lockQueryRowerxMockQueryRowx.Lock()
	mock.calls.QueryRowx = append(mock.calls.QueryRowx, callInfo)
	lockQueryRowerxMockQueryRowx.Unlock()
	return mock.QueryRowxFunc(query, args...)
}

// QueryRowxCalls gets all the calls that were made to QueryRowx.
// Check the length with:
//     len(mockedQueryRowerx.QueryRowxCalls())
func (mock *QueryRowerxMock) QueryRowxCalls() []struct {
	Query string
	Args  []interface{}
} {
	var calls []struct {
		Query string
		Args  []interface{}
	}
	lockQueryRowerxMockQueryRowx.RLock()
	calls = mock.calls.QueryRowx
	lockQueryRowerxMockQueryRowx.RUnlock()
	return calls
}

var (
	lockQueryRowerxContextMockQueryRowxContext sync.RWMutex
)

// Ensure, that QueryRowerxContextMock does implement QueryRowerxContext.
// If this is not the case, regenerate this file with moq.
var _ QueryRowerxContext = &QueryRowerxContextMock{}

// QueryRowerxContextMock is a mock implementation of QueryRowerxContext.
//
//     func TestSomethingThatUsesQueryRowerxContext(t *testing.T) {
//
//         // make and configure a mocked QueryRowerxContext
//         mockedQueryRowerxContext := &QueryRowerxContextMock{
//             QueryRowxContextFunc: func(ctx context.Context, query string, args ...interface{}) *sqlx.Row {
// 	               panic("mock out the QueryRowxContext method")
//             },
//         }
//
//         // use mockedQueryRowerxContext in code that requires QueryRowerxContext
//         // and then make assertions.
//
//     }
type QueryRowerxContextMock struct {
	// QueryRowxContextFunc mocks the QueryRowxContext method.
	QueryRowxContextFunc func(ctx context.Context, query string, args ...interface{}) *sqlx.Row

	// calls tracks calls to the methods.
	calls struct {
		// QueryRowxContext holds details about calls to the QueryRowxContext method.
		QueryRowxContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Query is the query argument value.
			Query string
			// Args is the args argument value.
			Args []interface{}
		}
	}
}

// QueryRowxContext calls QueryRowxContextFunc.
func (mock *QueryRowerxContextMock) QueryRowxContext(ctx context.Context, query string, args ...interface{}) *sqlx.Row {
	if mock.QueryRowxContextFunc == nil {
		panic("QueryRowerxContextMock.QueryRowxContextFunc: method is nil but QueryRowerxContext.QueryRowxContext was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Query string
		Args  []interface{}
	}{
		Ctx:   ctx,
		Query: query,
		Args:  args,
	}
	lockQueryRowerxContextMockQueryRowxContext.Lock()
	mock.calls.QueryRowxContext = append(mock.calls.QueryRowxContext, callInfo)
	lockQueryRowerxContextMockQueryRowxContext.Unlock()
	return mock.QueryRowxContextFunc(ctx, query, args...)
}

// QueryRowxContextCalls gets all the calls that were made to QueryRowxContext.
// Check the length with:
//     len(mockedQueryRowerxContext.QueryRowxContextCalls())
func (mock *QueryRowerxContextMock) QueryRowxContextCalls() []struct {
	Ctx   context.Context
	Query string
	Args  []interface{}
} {
	var calls []struct {
		Ctx   context.Context
		Query string
		Args  []interface{}
	}
	lockQueryRowerxContextMockQueryRowxContext.RLock()
	calls = mock.calls.QueryRowxContext
	lockQueryRowerxContextMockQueryRowxContext.RUnlock()
	return calls
}

var (
	lockMustExecerMockMustExec sync.RWMutex
)

// Ensure, that MustExecerMock does implement MustExecer.
// If this is not the case, regenerate this file with moq.
var _ MustExecer = &MustExecerMock{}

// MustExecerMock is a mock implementation of MustExecer.
//
//     func TestSomethingThatUsesMustExecer(t *testing.T) {
//
//         // make and configure a mocked MustExecer
//         mockedMustExecer := &MustExecerMock{
//             MustExecFunc: func(query string, args ...interface{}) sql.Result {
// 	               panic("mock out the MustExec method")
//             },
//         }
//
//         // use mockedMustExecer in code that requires MustExecer
//         // and then make assertions.
//
//     }
type MustExecerMock struct {
	// MustExecFunc mocks the MustExec method.
	MustExecFunc func(query string, args ...interface{}) sql.Result

	// calls tracks calls to the methods.
	calls struct {
		// MustExec holds details about calls to the MustExec method.
		MustExec []struct {
			// Query is the query argument value.
			Query string
			// Args is the args argument value.
			Args []interface{}
		}
	}
}

// MustExec calls MustExecFunc.
func (mock *MustExecerMock) MustExec(query string, args ...interface{}) sql.Result {
	if mock.MustExecFunc == nil {
		panic("MustExecerMock.MustExecFunc: method is nil but MustExecer.MustExec was just called")
	}
	callInfo := struct {
		Query string
		Args  []interface{}
	}{
		Query: query,
		Args:  args,
	}
	lockMustExecerMockMustExec.Lock()
	mock.calls.MustExec = append(mock.calls.MustExec, callInfo)
	lockMustExecerMockMustExec.Unlock()
	return mock.MustExecFunc(query, args...)
}

// MustExecCalls gets all the calls that were made to MustExec.
// Check the length with:
//     len(mockedMustExecer.MustExecCalls())
func (mock *MustExecerMock) MustExecCalls() []struct {
	Query string
	Args  []interface{}
} {
	var calls []struct {
		Query string
		Args  []interface{}
	}
	lockMustExecerMockMustExec.RLock()
	calls = mock.calls.MustExec
	lockMustExecerMockMustExec.RUnlock()
	return calls
}

var (
	lockMustExecerContextMockMustExecContext sync.RWMutex
)

// Ensure, that MustExecerContextMock does implement MustExecerContext.
// If this is not the case, regenerate this file with moq.
var _ MustExecerContext = &MustExecerContextMock{}

// MustExecerContextMock is a mock implementation of MustExecerContext.
//
//     func TestSomethingThatUsesMustExecerContext(t *testing.T) {
//
//         // make and configure a mocked MustExecerContext
//         mockedMustExecerContext := &MustExecerContextMock{
//             MustExecContextFunc: func(ctx context.Context, query string, args ...interface{}) sql.Result {
// 	               panic("mock out the MustExecContext method")
//             },
//         }
//
//         // use mockedMustExecerContext in code that requires MustExecerContext
//         // and then make assertions.
//
//     }
type MustExecerContextMock struct {
	// MustExecContextFunc mocks the MustExecContext method.
	MustExecContextFunc func(ctx context.Context, query string, args ...interface{}) sql.Result

	// calls tracks calls to the methods.
	calls struct {
		// MustExecContext holds details about calls to the MustExecContext method.
		MustExecContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Query is the query argument value.
			Query string
			// Args is the args argument value.
			Args []interface{}
		}
	}
}

// MustExecContext calls MustExecContextFunc.
func (mock *MustExecerContextMock) MustExecContext(ctx context.Context, query string, args ...interface{}) sql.Result {
	if mock.MustExecContextFunc == nil {
		panic("MustExecerContextMock.MustExecContextFunc: method is nil but MustExecerContext.MustExecContext was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Query string
		Args  []interface{}
	}{
		Ctx:   ctx,
		Query: query,
		Args:  args,
	}
	lockMustExecerContextMockMustExecContext.Lock()
	mock.calls.MustExecContext = append(mock.calls.MustExecContext, callInfo)
	lockMustExecerContextMockMustExecContext.Unlock()
	return mock.MustExecContextFunc(ctx, query, args...)
}

// MustExecContextCalls gets all the calls that were made to MustExecContext.
// Check the length with:
//     len(mockedMustExecerContext.MustExecContextCalls())
func (mock *MustExecerContextMock) MustExecContextCalls() []struct {
	Ctx   context.Context
	Query string
	Args  []interface{}
} {
	var calls []struct {
		Ctx   context.Context
		Query string
		Args  []interface{}
	}
	lockMustExecerContextMockMustExecContext.RLock()
	calls = mock.calls.MustExecContext
	lockMustExecerContextMockMustExecContext.RUnlock()
	return calls
}

var (
	lockRebinderMockRebind sync.RWMutex
)

// Ensure, that RebinderMock does implement Rebinder.
// If this is not the case, regenerate this file with moq.
var _ Rebinder = &RebinderMock{}

// RebinderMock is a mock implementation of Rebinder.
//
//     func TestSomethingThatUsesRebinder(t *testing.T) {
//
//         // make and configure a mocked Rebinder
//         mockedRebinder := &RebinderMock{
//             RebindFunc: func(query string) string {
// 	               panic("mock out the Rebind method")
//             },
//         }
//
//         // use mockedRebinder in code that requires Rebinder
//         // and then make assertions.
//
//     }
type RebinderMock struct {
	// RebindFunc mocks the Rebind method.
	RebindFunc func(query string) string

	// calls tracks calls to the methods.
	calls struct {
		// Rebind holds details about calls to the Rebind method.
		Rebind []struct {
			// Query is the query argument value.
			Query string
		}
	}
}

// Rebind calls RebindFunc.
func (mock *RebinderMock) Rebind(query string) string {
	if mock.RebindFunc == nil {
		panic("RebinderMock.RebindFunc: method is nil but Rebinder.Rebind was just called")
	}
	callInfo := struct {
		Query string
	}{
		Query: query,
	}
	lockRebinderMockRebind.Lock()
	mock.calls.Rebind = append(mock.calls.Rebind, callInfo)
	lockRebinderMockRebind.Unlock()
	return mock.RebindFunc(query)
}

// RebindCalls gets all the calls that were made to Rebind.
// Check the length with:
//     len(mockedRebinder.RebindCalls())
func (mock *RebinderMock) RebindCalls() []struct {
	Query string
} {
	var calls []struct {
		Query string
	}
	lockRebinderMockRebind.RLock()
	calls = mock.calls.Rebind
	lockRebinderMockRebind.RUnlock()
	return calls
}

var (
	lockNamedPreparerMockPrepareNamed sync.RWMutex
)

// Ensure, that NamedPreparerMock does implement NamedPreparer.
// If this is not the case, regenerate this file with moq.
var _ NamedPreparer = &NamedPreparerMock{}

// NamedPreparerMock is a mock implementation of NamedPreparer.
//
//     func TestSomethingThatUsesNamedPreparer(t *testing.T) {
//
//         // make and configure a mocked NamedPreparer
//         mockedNamedPreparer := &NamedPreparerMock{
//             PrepareNamedFunc: func(query string) (*sqlx.NamedStmt, error) {
// 	               panic("mock out the PrepareNamed method")
//             },
//         }
//
//         // use mockedNamedPreparer in code that requires NamedPreparer
//         // and then make assertions.
//
//     }
type NamedPreparerMock struct {
	// PrepareNamedFunc mocks the PrepareNamed method.
	PrepareNamedFunc func(query string) (*sqlx.NamedStmt, error)

	// calls tracks calls to the methods.
	calls struct {
		// PrepareNamed holds details about calls to the PrepareNamed method.
		PrepareNamed []struct {
			// Query is the query argument value.
			Query string
		}
	}
}

// PrepareNamed calls PrepareNamedFunc.
func (mock *NamedPreparerMock) PrepareNamed(query string) (*sqlx.NamedStmt, error) {
	if mock.PrepareNamedFunc == nil {
		panic("NamedPreparerMock.PrepareNamedFunc: method is nil but NamedPreparer.PrepareNamed was just called")
	}
	callInfo := struct {
		Query string
	}{
		Query: query,
	}
	lockNamedPreparerMockPrepareNamed.Lock()
	mock.calls.PrepareNamed = append(mock.calls.PrepareNamed, callInfo)
	lockNamedPreparerMockPrepareNamed.Unlock()
	return mock.PrepareNamedFunc(query)
}

// PrepareNamedCalls gets all the calls that were made to PrepareNamed.
// Check the length with:
//     len(mockedNamedPreparer.PrepareNamedCalls())
func (mock *NamedPreparerMock) PrepareNamedCalls() []struct {
	Query string
} {
	var calls []struct {
		Query string
	}
	lockNamedPreparerMockPrepareNamed.RLock()
	calls = mock.calls.PrepareNamed
	lockNamedPreparerMockPrepareNamed.RUnlock()
	return calls
}

var (
	lockNamedPreparerContextMockPrepareNamedContext sync.RWMutex
)

// Ensure, that NamedPreparerContextMock does implement NamedPreparerContext.
// If this is not the case, regenerate this file with moq.
var _ NamedPreparerContext = &NamedPreparerContextMock{}

// NamedPreparerContextMock is a mock implementation of NamedPreparerContext.
//
//     func TestSomethingThatUsesNamedPreparerContext(t *testing.T) {
//
//         // make and configure a mocked NamedPreparerContext
//         mockedNamedPreparerContext := &NamedPreparerContextMock{
//             PrepareNamedContextFunc: func(ctx context.Context, query string) (*sqlx.NamedStmt, error) {
// 	               panic("mock out the PrepareNamedContext method")
//             },
//         }
//
//         // use mockedNamedPreparerContext in code that requires NamedPreparerContext
//         // and then make assertions.
//
//     }
type NamedPreparerContextMock struct {
	// PrepareNamedContextFunc mocks the PrepareNamedContext method.
	PrepareNamedContextFunc func(ctx context.Context, query string) (*sqlx.NamedStmt, error)

	// calls tracks calls to the methods.
	calls struct {
		// PrepareNamedContext holds details about calls to the PrepareNamedContext method.
		PrepareNamedContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Query is the query argument value.
			Query string
		}
	}
}

// PrepareNamedContext calls PrepareNamedContextFunc.
func (mock *NamedPreparerContextMock) PrepareNamedContext(ctx context.Context, query string) (*sqlx.NamedStmt, error) {
	if mock.PrepareNamedContextFunc == nil {
		panic("NamedPreparerContextMock.PrepareNamedContextFunc: method is nil but NamedPreparerContext.PrepareNamedContext was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Query string
	}{
		Ctx:   ctx,
		Query: query,
	}
	lockNamedPreparerContextMockPrepareNamedContext.Lock()
	mock.calls.PrepareNamedContext = append(mock.calls.PrepareNamedContext, callInfo)
	lockNamedPreparerContextMockPrepareNamedContext.Unlock()
	return mock.PrepareNamedContextFunc(ctx, query)
}

// PrepareNamedContextCalls gets all the calls that were made to PrepareNamedContext.
// Check the length with:
//     len(mockedNamedPreparerContext.PrepareNamedContextCalls())
func (mock *NamedPreparerContextMock) PrepareNamedContextCalls() []struct {
	Ctx   context.Context
	Query string
} {
	var calls []struct {
		Ctx   context.Context
		Query string
	}
	lockNamedPreparerContextMockPrepareNamedContext.RLock()
	calls = mock.calls.PrepareNamedContext
	lockNamedPreparerContextMockPrepareNamedContext.RUnlock()
	return calls
}

var (
	lockNamedQueryerMockNamedQuery sync.RWMutex
)

// Ensure, that NamedQueryerMock does implement NamedQueryer.
// If this is not the case, regenerate this file with moq.
var _ NamedQueryer = &NamedQueryerMock{}

// NamedQueryerMock is a mock implementation of NamedQueryer.
//
//     func TestSomethingThatUsesNamedQueryer(t *testing.T) {
//
//         // make and configure a mocked NamedQueryer
//         mockedNamedQueryer := &NamedQueryerMock{
//             NamedQueryFunc: func(query string, arg interface{}) (*sqlx.Rows, error) {
// 	               panic("mock out the NamedQuery method")
//             },
//         }
//
//         // use mockedNamedQueryer in code that requires NamedQueryer
//         // and then make assertions.
//
//     }
type NamedQueryerMock struct {
	// NamedQueryFunc mocks the NamedQuery method.
	NamedQueryFunc func(query string, arg interface{}) (*sqlx.Rows, error)

	// calls tracks calls to the methods.
	calls struct {
		// NamedQuery holds details about calls to the NamedQuery method.
		NamedQuery []struct {
			// Query is the query argument value.
			Query string
			// Arg is the arg argument value.
			Arg interface{}
		}
	}
}

// NamedQuery calls NamedQueryFunc.
func (mock *NamedQueryerMock) NamedQuery(query string, arg interface{}) (*sqlx.Rows, error) {
	if mock.NamedQueryFunc == nil {
		panic("NamedQueryerMock.NamedQueryFunc: method is nil but NamedQueryer.NamedQuery was just called")
	}
	callInfo := struct {
		Query string
		Arg   interface{}
	}{
		Query: query,
		Arg:   arg,
	}
	lockNamedQueryerMockNamedQuery.Lock()
	mock.calls.NamedQuery = append(mock.calls.NamedQuery, callInfo)
	lockNamedQueryerMockNamedQuery.Unlock()
	return mock.NamedQueryFunc(query, arg)
}

// NamedQueryCalls gets all the calls that were made to NamedQuery.
// Check the length with:
//     len(mockedNamedQueryer.NamedQueryCalls())
func (mock *NamedQueryerMock) NamedQueryCalls() []struct {
	Query string
	Arg   interface{}
} {
	var calls []struct {
		Query string
		Arg   interface{}
	}
	lockNamedQueryerMockNamedQuery.RLock()
	calls = mock.calls.NamedQuery
	lockNamedQueryerMockNamedQuery.RUnlock()
	return calls
}

var (
	lockNamedQueryerContextMockNamedQueryContext sync.RWMutex
)

// Ensure, that NamedQueryerContextMock does implement NamedQueryerContext.
// If this is not the case, regenerate this file with moq.
var _ NamedQueryerContext = &NamedQueryerContextMock{}

// NamedQueryerContextMock is a mock implementation of NamedQueryerContext.
//
//     func TestSomethingThatUsesNamedQueryerContext(t *testing.T) {
//
//         // make and configure a mocked NamedQueryerContext
//         mockedNamedQueryerContext := &NamedQueryerContextMock{
//             NamedQueryContextFunc: func(ctx context.Context, query string, arg interface{}) (*sqlx.Rows, error) {
// 	               panic("mock out the NamedQueryContext method")
//             },
//         }
//
//         // use mockedNamedQueryerContext in code that requires NamedQueryerContext
//         // and then make assertions.
//
//     }
type NamedQueryerContextMock struct {
	// NamedQueryContextFunc mocks the NamedQueryContext method.
	NamedQueryContextFunc func(ctx context.Context, query string, arg interface{}) (*sqlx.Rows, error)

	// calls tracks calls to the methods.
	calls struct {
		// NamedQueryContext holds details about calls to the NamedQueryContext method.
		NamedQueryContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Query is the query argument value.
			Query string
			// Arg is the arg argument value.
			Arg interface{}
		}
	}
}

// NamedQueryContext calls NamedQueryContextFunc.
func (mock *NamedQueryerContextMock) NamedQueryContext(ctx context.Context, query string, arg interface{}) (*sqlx.Rows, error) {
	if mock.NamedQueryContextFunc == nil {
		panic("NamedQueryerContextMock.NamedQueryContextFunc: method is nil but NamedQueryerContext.NamedQueryContext was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Query string
		Arg   interface{}
	}{
		Ctx:   ctx,
		Query: query,
		Arg:   arg,
	}
	lockNamedQueryerContextMockNamedQueryContext.Lock()
	mock.calls.NamedQueryContext = append(mock.calls.NamedQueryContext, callInfo)
	lockNamedQueryerContextMockNamedQueryContext.Unlock()
	return mock.NamedQueryContextFunc(ctx, query, arg)
}

// NamedQueryContextCalls gets all the calls that were made to NamedQueryContext.
// Check the length with:
//     len(mockedNamedQueryerContext.NamedQueryContextCalls())
func (mock *NamedQueryerContextMock) NamedQueryContextCalls() []struct {
	Ctx   context.Context
	Query string
	Arg   interface{}
} {
	var calls []struct {
		Ctx   context.Context
		Query string
		Arg   interface{}
	}
	lockNamedQueryerContextMockNamedQueryContext.RLock()
	calls = mock.calls.NamedQueryContext
	lockNamedQueryerContextMockNamedQueryContext.RUnlock()
	return calls
}

var (
	lockNamedExecerMockNamedExec sync.RWMutex
)

// Ensure, that NamedExecerMock does implement NamedExecer.
// If this is not the case, regenerate this file with moq.
var _ NamedExecer = &NamedExecerMock{}

// NamedExecerMock is a mock implementation of NamedExecer.
//
//     func TestSomethingThatUsesNamedExecer(t *testing.T) {
//
//         // make and configure a mocked NamedExecer
//         mockedNamedExecer := &NamedExecerMock{
//             NamedExecFunc: func(query string, arg interface{}) (sql.Result, error) {
// 	               panic("mock out the NamedExec method")
//             },
//         }
//
//         // use mockedNamedExecer in code that requires NamedExecer
//         // and then make assertions.
//
//     }
type NamedExecerMock struct {
	// NamedExecFunc mocks the NamedExec method.
	NamedExecFunc func(query string, arg interface{}) (sql.Result, error)

	// calls tracks calls to the methods.
	calls struct {
		// NamedExec holds details about calls to the NamedExec method.
		NamedExec []struct {
			// Query is the query argument value.
			Query string
			// Arg is the arg argument value.
			Arg interface{}
		}
	}
}

// NamedExec calls NamedExecFunc.
func (mock *NamedExecerMock) NamedExec(query string, arg interface{}) (sql.Result, error) {
	if mock.NamedExecFunc == nil {
		panic("NamedExecerMock.NamedExecFunc: method is nil but NamedExecer.NamedExec was just called")
	}
	callInfo := struct {
		Query string
		Arg   interface{}
	}{
		Query: query,
		Arg:   arg,
	}
	lockNamedExecerMockNamedExec.Lock()
	mock.calls.NamedExec = append(mock.calls.NamedExec, callInfo)
	lockNamedExecerMockNamedExec.Unlock()
	return mock.NamedExecFunc(query, arg)
}

// NamedExecCalls gets all the calls that were made to NamedExec.
// Check the length with:
//     len(mockedNamedExecer.NamedExecCalls())
func (mock *NamedExecerMock) NamedExecCalls() []struct {
	Query string
	Arg   interface{}
} {
	var calls []struct {
		Query string
		Arg   interface{}
	}
	lockNamedExecerMockNamedExec.RLock()
	calls = mock.calls.NamedExec
	lockNamedExecerMockNamedExec.RUnlock()
	return calls
}

var (
	lockNamedExecerContextMockNamedExecContext sync.RWMutex
)

// Ensure, that NamedExecerContextMock does implement NamedExecerContext.
// If this is not the case, regenerate this file with moq.
var _ NamedExecerContext = &NamedExecerContextMock{}

// NamedExecerContextMock is a mock implementation of NamedExecerContext.
//
//     func TestSomethingThatUsesNamedExecerContext(t *testing.T) {
//
//         // make and configure a mocked NamedExecerContext
//         mockedNamedExecerContext := &NamedExecerContextMock{
//             NamedExecContextFunc: func(ctx context.Context, query string, arg interface{}) (sql.Result, error) {
// 	               panic("mock out the NamedExecContext method")
//             },
//         }
//
//         // use mockedNamedExecerContext in code that requires NamedExecerContext
//         // and then make assertions.
//
//     }
type NamedExecerContextMock struct {
	// NamedExecContextFunc mocks the NamedExecContext method.
	NamedExecContextFunc func(ctx context.Context, query string, arg interface{}) (sql.Result, error)

	// calls tracks calls to the methods.
	calls struct {
		// NamedExecContext holds details about calls to the NamedExecContext method.
		NamedExecContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Query is the query argument value.
			Query string
			// Arg is the arg argument value.
			Arg interface{}
		}
	}
}

// NamedExecContext calls NamedExecContextFunc.
func (mock *NamedExecerContextMock) NamedExecContext(ctx context.Context, query string, arg interface{}) (sql.Result, error) {
	if mock.NamedExecContextFunc == nil {
		panic("NamedExecerContextMock.NamedExecContextFunc: method is nil but NamedExecerContext.NamedExecContext was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Query string
		Arg   interface{}
	}{
		Ctx:   ctx,
		Query: query,
		Arg:   arg,
	}
	lockNamedExecerContextMockNamedExecContext.Lock()
	mock.calls.NamedExecContext = append(mock.calls.NamedExecContext, callInfo)
	lockNamedExecerContextMockNamedExecContext.Unlock()
	return mock.NamedExecContextFunc(ctx, query, arg)
}

// NamedExecContextCalls gets all the calls that were made to NamedExecContext.
// Check the length with:
//     len(mockedNamedExecerContext.NamedExecContextCalls())
func (mock *NamedExecerContextMock) NamedExecContextCalls() []struct {
	Ctx   context.Context
	Query string
	Arg   interface{}
} {
	var calls []struct {
		Ctx   context.Context
		Query string
		Arg   interface{}
	}
	lockNamedExecerContextMockNamedExecContext.RLock()
	calls = mock.calls.NamedExecContext
	lockNamedExecerContextMockNamedExecContext.RUnlock()
	return calls
}

var (
	lockNamedBinderMockBindNamed sync.RWMutex
)

// Ensure, that NamedBinderMock does implement NamedBinder.
// If this is not the case, regenerate this file with moq.
var _ NamedBinder = &NamedBinderMock{}

// NamedBinderMock is a mock implementation of NamedBinder.
//
//     func TestSomethingThatUsesNamedBinder(t *testing.T) {
//
//         // make and configure a mocked NamedBinder
//         mockedNamedBinder := &NamedBinderMock{
//             BindNamedFunc: func(query string, arg interface{}) (string, []interface{}, error) {
// 	               panic("mock out the BindNamed method")
//             },
//         }
//
//         // use mockedNamedBinder in code that requires NamedBinder
//         // and then make assertions.
//
//     }
type NamedBinderMock struct {
	// BindNamedFunc mocks the BindNamed method.
	BindNamedFunc func(query string, arg interface{}) (string, []interface{}, error)

	// calls tracks calls to the methods.
	calls struct {
		// BindNamed holds details about calls to the BindNamed method.
		BindNamed []struct {
			// Query is the query argument value.
			Query string
			// Arg is the arg argument value.
			Arg interface{}
		}
	}
}

// BindNamed calls BindNamedFunc.
func (mock *NamedBinderMock) BindNamed(query string, arg interface{}) (string, []interface{}, error) {
	if mock.BindNamedFunc == nil {
		panic("NamedBinderMock.BindNamedFunc: method is nil but NamedBinder.BindNamed was just called")
	}
	callInfo := struct {
		Query string
		Arg   interface{}
	}{
		Query: query,
		Arg:   arg,
	}
	lockNamedBinderMockBindNamed.Lock()
	mock.calls.BindNamed = append(mock.calls.BindNamed, callInfo)
	lockNamedBinderMockBindNamed.Unlock()
	return mock.BindNamedFunc(query, arg)
}

// BindNamedCalls gets all the calls that were made to BindNamed.
// Check the length with:
//     len(mockedNamedBinder.BindNamedCalls())
func (mock *NamedBinderMock) BindNamedCalls() []struct {
	Query string
	Arg   interface{}
} {
	var calls []struct {
		Query string
		Arg   interface{}
	}
	lockNamedBinderMockBindNamed.RLock()
	calls = mock.calls.BindNamed
	lockNamedBinderMockBindNamed.RUnlock()
	return calls
}
